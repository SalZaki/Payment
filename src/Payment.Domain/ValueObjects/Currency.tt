<#
    // Author: Sal Zaki
    // Recommendation:
    // Don't edit this file in Visual Studio. Download VS Code and this extension:
    // https://marketplace.visualstudio.com/items?itemName=zbecknell.t4-support
#>
<#@ template hostspecific="false" language="C#" #>
<#@ output extension="Generated.cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="System.Net.Http" #>
<#@ assembly name="System.Runtime.Serialization" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Net" #>
<#@ import namespace="System.Net.Http" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Threading.Tasks" #>
<#@ import namespace="System.Threading" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Xml.Serialization" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Schema" #>
<#@ import namespace="System.IO" #>
<#
  const string isoUrl = "https://www.six-group.com/dam/download/financial-information/data-center/iso-currrency/lists/list-one.xml";
  var isoCurrencyReader = new IsoCurrencyReader(isoUrl);
  var currencies = isoCurrencyReader.ReadAsync().Result;

  var validCurrencies = currencies.Where(x => x.CurrencyNumber.Value != null && x.MinorUnits.Value != null)
    .ToLookup(x => new
    {
      x.CurrencyName,
      x.CurrencyCode,
      CurrencyNumber = x.CurrencyNumber.Value,
      MinorUnits = x.MinorUnits.Value
    }, x => x);

  var invalidCurrencies = currencies.Where(x => x.CurrencyNumber.Value == null || x.MinorUnits.Value == null)
    .ToList()
    .AsReadOnly();
#>
// ------------------------------------------------------------------------------
// Author: Sal Zaki
// <auto-generated>
//   This code has been auto-generated by the associated .tt file.
//   Any changes made to in this file will be lost when the file is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
#nullable enable

using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace Payment.Domain.ValueObjects;

/// <summary>
/// ISO4217 representation <#= currencies.Count #> of fiat currencies.
/// </summary>
/// <remarks> Currencies not included:
/// <#=string.Join(", ", invalidCurrencies.Select(x => $"'{x.CountryName}'"))#>
/// </remarks>
/// <remarks> Published On: <#= currencies.PublishedOn #> </remarks>
/// <remarks> Build On: <#= DateTime.UtcNow #> </remarks>
/// <remarks> Source: <#= isoUrl #> </remarks>
public partial record Currency
{
<#
  foreach (var isoCurrency in validCurrencies)
  {
    var countries = string.Join(", ", isoCurrency.Select(x => "\"" + x.CountryName.Replace("\"", "\\\"") + "\""));
    var currency = isoCurrency.Key;
#>

  /// <summary>
  /// ISO4217 currency representation of <#= currency.CurrencyName #> (<#= currency.CurrencyCode #>).
  /// </summary>
<#
    if (isoCurrency.Count() > 1)
    {
#>  /// <remarks> Countries: <#=
      string.Join(", ", isoCurrency.Select(x => x.CountryName)) #> </remarks>
<#
    }
    else
    {
#>  /// <remarks> Country: <#= isoCurrency.FirstOrDefault().CountryName #> </remarks>
<#
    }
#>
  /// <remarks> Name: <#= currency.CurrencyName #> </remarks>
  /// <remarks> Code: <#= currency.CurrencyCode #> </remarks>
  /// <remarks> Number: <#= currency.CurrencyNumber #> </remarks>
  /// <remarks> Minor Units: <#= currency.MinorUnits #> </remarks>
  public static readonly Currency <#= currency.CurrencyCode #> = Currency.Create("<#= currency.CurrencyName #>", "<#= currency.CurrencyCode #>", <#= currency.CurrencyNumber.Value #>, <#= currency.MinorUnits.Value #>, new []{ <#= countries #> });
<#
  }

  var currencyCodes = validCurrencies.Select(x => x.Key.CurrencyCode);
#>

  /// <summary>
  /// All valid ISO4217 currencies
  /// </summary>
  public static readonly HashSet<Currency> Currencies = new HashSet<Currency>(new [] { <#=string.Join(", ", currencyCodes)#> });

  /// <summary>
  /// A case-insensitive, trailing and leading whitespace friendly lookup
  /// </summary>
  private static IReadOnlyDictionary<string, Currency> CurrencyCodeLookup = new ReadOnlyDictionary<string, Currency>(new Dictionary<string, Currency>(new InvariantCultureIgnoreCaseTrimmedEqualityStringComparer())
  {
<#
  foreach(var currency in validCurrencies)
  {
#>
    {"<#=currency.Key.CurrencyCode#>", <#=currency.Key.CurrencyCode#>},
<#
  }
#>
  });

  /// <summary>
  /// Currency number lookup
  /// </summary>
  private static IReadOnlyDictionary<int, Currency> CurrencyNumberLookup = new ReadOnlyDictionary<int, Currency>(new Dictionary<int, Currency>
  {
<#
  foreach(var currency in validCurrencies)
  {
#>
    {<#=currency.Key.CurrencyNumber.Value#>, <#=currency.Key.CurrencyCode#>},
<#
  }
#>
  });
}

#nullable restore

<#+

  public readonly struct IsoCurrencyReader
  {
    private Uri IsoUrl { get; }

    public IsoCurrencyReader(string url)
    {
      IsoUrl = IsValidUrl(url) ? new Uri(url) : throw new ArgumentException("Invalid url", nameof(url));
    }

    private async Task<Stream> GetStreamAsync(CancellationToken cancellationToken)
    {
      using var httpClient = new HttpClient();
      httpClient.Timeout = TimeSpan.FromMilliseconds(30000);
      ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;
      var response = await httpClient.GetAsync(IsoUrl, cancellationToken);
      return await response.Content.ReadAsStreamAsync();
    }

    private static bool IsValidUrl(string url) => !string.IsNullOrEmpty(url) && !string.IsNullOrWhiteSpace(url);

    public async Task<IsoCurrencies> ReadAsync(CancellationToken cancellationToken = default)
    {
      var stream = await GetStreamAsync(cancellationToken);
      var serializer = new XmlSerializer(typeof(Iso4217Element));
      var doc = (Iso4217Element?) serializer.Deserialize(stream);
      var currencies = new IsoCurrencies();
      if (doc is null) return currencies;
      currencies.AddRange(doc.Value.CountryTable.Countries);
      currencies.SetPublishedOn(doc.Value.PublishedOn);
      return currencies;
    }
  }

  [XmlRoot("ISO_4217")]
  public struct Iso4217Element
  {
    [XmlAttribute("Pblshd")]
    public DateTime PublishedOn { get; set; }

    [XmlElement("CcyTbl")]
    public CountryTableElement CountryTable { get; set; }
  }

  public struct CountryTableElement
  {
    [XmlElement("CcyNtry")]
    public IsoCurrency[] Countries { get; set; }
  }

  public struct IsoCurrencies : IReadOnlyCollection<IsoCurrency>
  {
    public int Count => _currencies.Count;

    private readonly List<IsoCurrency> _currencies = new();

    public DateTime PublishedOn { get; private set; }

    public IsoCurrencies()
    {
    }

    public void SetPublishedOn(DateTime publishedOn)
    {
      PublishedOn = publishedOn;
    }

    public void AddRange(IEnumerable<IsoCurrency> isoCurrencies)
    {
      foreach (var isoCurrency in isoCurrencies)
      {
        _currencies.Add(isoCurrency);
      }
    }

    public IEnumerator<IsoCurrency> GetEnumerator() => _currencies.GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public bool Exists(IsoCurrency isoCurrency) => _currencies.Any(x => SearchPredicate(x, isoCurrency.CountryName));

    public IsoCurrency TryFind(string countryName) => _currencies.FirstOrDefault(x => SearchPredicate(x, countryName));

    private static readonly Func<IsoCurrency, string, bool> SearchPredicate =
      (p, name) => p.CountryName.Equals(name, StringComparison.InvariantCultureIgnoreCase);
  }

  public struct IsoCurrency
  {
    [XmlElement("Ccy")]
    public string CurrencyCode { get; set; }

    [XmlElement("CtryNm")]
    public string CountryName { get; set; }

    [XmlElement("CcyNm")]
    public string CurrencyName { get; set; }

    [XmlElement("CcyNbr")]
    public CurrencyNumber CurrencyNumber { get; set; }

    [XmlElement("CcyMnrUnts")]
    public MinorUnits MinorUnits { get; set; }
  }

  public struct CurrencyNumber : IXmlSerializable, IEquatable<int>
  {
    public int? Value { get; private set; }

    public bool HasValue => Value.HasValue;

    public XmlSchema GetSchema()
    {
      return null;
    }

    public void ReadXml(XmlReader reader)
    {
      var read = reader.ReadString();
      reader.ReadEndElement();
      Value = int.TryParse(read, out var parsed) && parsed > 0 ? parsed : default(int?);
    }

    public void WriteXml(XmlWriter writer)
    {
      throw new NotImplementedException("This is read only");
    }

    public bool Equals(int other)
    {
      return Value.HasValue && Convert.ToInt32(Value.Value).Equals(other);
    }

    public override string ToString()
    {
      return Value.ToString();
    }
  }

  public struct MinorUnits : IXmlSerializable, IEquatable<int>
  {
    public int? Value { get; private set; }

    public bool HasValue => Value.HasValue;

    public XmlSchema GetSchema()
    {
      return null;
    }

    public void ReadXml(XmlReader reader)
    {
      var read = reader.ReadString();
      reader.ReadEndElement();
      Value = int.TryParse(read, out var parsed) ? parsed : default(int?);
    }

    public void WriteXml(XmlWriter writer)
    {
      throw new NotImplementedException("This is read only");
    }

    public bool Equals(int other)
    {
      return Value.HasValue && Convert.ToInt32(Value.Value).Equals(other);
    }

    public override string ToString()
    {
      return Value.ToString();
    }
  }
#>
